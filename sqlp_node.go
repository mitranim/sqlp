package sqlp

/*
Notes on node representation

In a language with variant types (tagged unions), we would have represented
tokens/nodes as a variant. Go lacks variants, so the closest alternatives are:

	1) Emulating a variant type by using a struct where every field is a pointer,
	and only one field must be non-nil. Type detection is performed by checking
	which of the fields is non-nil.

	2) Using a single struct type, with an explicit type field. Type detection is
	performed by comparing the type field to constants.

	3) Using an interface and a collection of concrete types implementing it. Type
	detection is performed by unwrapping the interface and checking the
	underlying concrete type.

Problems with (1): it allows too many invalid representations; it makes it hard
or annoying to check the type.

Problem with (2): the single node type must have the fields to support every
possible node, but not every type uses every field. It makes it too hard to
express or undestand which representations are valid, and makes invalid
representations too likely.

Problem with (3): it may involve more individual heap allocations and
indirections. But unlike the other two, it allows extremely simple specialized
node types, which may ultimately use less memory, and avoids invalid
representations. Unlike the other two, (3) allows the set of possible values to
be open. The user may introduce additional AST nodes that the parser didn't
know about, though this only goes from AST to formatted code, not the other
direction.

Misc notes

The parser accumulates unrecognized content until it finds some "known" syntax,
at which point it emits the accumulation as `NodeWhitespace` and/or
`NodeText`.

The token stream or parsed AST must serialize back into EXACTLY the source
content.
*/

import (
	"strconv"
)

// Arbitrary non-whitespace text that wasn't recognized by the parser. When
// generated by the parser, the node is always non-empty and consists entirely
// of non-whitespace characters.
type NodeText string

func (self NodeText) Append(buf []byte) []byte { return append(buf, self...) }
func (self NodeText) String() string           { return appenderStr(&self) }

// Whitespace. When generated by the parser, the node is always non-empty and
// consists entirely of whitespace characters.
type NodeWhitespace string

func (self NodeWhitespace) Append(buf []byte) []byte { return append(buf, self...) }
func (self NodeWhitespace) String() string           { return appenderStr(&self) }

func (self NodeWhitespace) Node() Node {
	if self == ` ` {
		return nodeWhitespaceSingle
	}
	return self
}

// Text inside single quotes: ''. Escape sequences are not supported yet.
type NodeQuoteSingle string

func (self NodeQuoteSingle) Append(buf []byte) []byte {
	buf = append(buf, quoteSingle)
	buf = append(buf, self...)
	buf = append(buf, quoteSingle)
	return buf
}

func (self NodeQuoteSingle) String() string { return appenderStr(&self) }

// Text inside double quotes: "". Escape sequences are not supported yet.
type NodeQuoteDouble string

func (self NodeQuoteDouble) Append(buf []byte) []byte {
	buf = append(buf, quoteDouble)
	buf = append(buf, self...)
	buf = append(buf, quoteDouble)
	return buf
}

func (self NodeQuoteDouble) String() string { return appenderStr(&self) }

// Text inside grave quotes: ``. Escape sequences are not supported yet.
type NodeQuoteGrave string

func (self NodeQuoteGrave) Append(buf []byte) []byte {
	buf = append(buf, quoteGrave)
	buf = append(buf, self...)
	buf = append(buf, quoteGrave)
	return buf
}

func (self NodeQuoteGrave) String() string { return appenderStr(&self) }

// Content of a line comment: --, including the newline.
type NodeCommentLine string

func (self NodeCommentLine) Append(buf []byte) []byte {
	buf = append(buf, commentLinePrefix...)
	buf = append(buf, self...)
	return buf
}

func (self NodeCommentLine) String() string { return appenderStr(&self) }

// Content of a block comment: /* */.
type NodeCommentBlock string

func (self NodeCommentBlock) Append(buf []byte) []byte {
	buf = append(buf, commentBlockPrefix...)
	buf = append(buf, self...)
	buf = append(buf, commentBlockSuffix...)
	return buf
}

func (self NodeCommentBlock) String() string { return appenderStr(&self) }

// Postgres cast operator: ::. Allows to disambiguate casts from named params.
type NodeDoubleColon struct{}

func (self NodeDoubleColon) Append(buf []byte) []byte { return append(buf, castPrefix...) }
func (self NodeDoubleColon) String() string           { return castPrefix }

// Postgres-style ordinal parameter placeholder: $1, $2, $3, ...
type NodeOrdinalParam int

func (self NodeOrdinalParam) Append(buf []byte) []byte {
	buf = append(buf, ordinalPrefix)
	buf = strconv.AppendInt(buf, int64(self), 10)
	return buf
}

func (self NodeOrdinalParam) String() string { return appenderStr(&self) }

// Convenience method that returns the corresponding Go index (starts at zero).
func (self NodeOrdinalParam) Index() int { return int(self) - 1 }

// Named parameter preceded by colon: :identifier
type NodeNamedParam string

func (self NodeNamedParam) Append(buf []byte) []byte {
	buf = append(buf, namedPrefix)
	buf = append(buf, self...)
	return buf
}

func (self NodeNamedParam) String() string { return appenderStr(&self) }

/*
Arbitrary sequence of AST nodes. When serializing, doesn't print any start or
end delimiters.
*/
type Nodes []Node

/*
Implement the `Node` interface. Simply concatenates the stringified
representations of the inner nodes, skipping any nil nodes.

`Nodes` can be arbitrarily nested without affecting the output. For example,
both `Nodes{}` and `Nodes{Nodes{}}` will print "".
*/
func (self Nodes) Append(buf []byte) []byte {
	for _, node := range self {
		if node != nil {
			buf = node.Append(buf)
		}
	}
	return buf
}

func (self Nodes) String() string { return appenderStr(&self) }

func (self Nodes) Nodes() Nodes { return self }

// Implement `Walker`. Calls `fun` for each non-nil node in the sequence.
func (self Nodes) WalkNode(fun func(Node)) {
	if fun == nil {
		return
	}
	for _, val := range self {
		if val != nil {
			fun(val)
		}
	}
}

// Implement `PtrWalker`. Calls `fun` for each non-nil node in the sequence.
func (self Nodes) WalkNodePtr(fun func(*Node)) {
	if fun == nil {
		return
	}
	for i := range self {
		if self[i] != nil {
			fun(&self[i])
		}
	}
}

// Makes a deep copy whose mutations won't affect the original.
func (self Nodes) CopyNodes() Nodes {
	if self == nil {
		return nil
	}
	out := make(Nodes, len(self))
	for i := range self {
		out[i] = CopyNode(self[i])
	}
	return out
}

// Implements `Copier` by calling `Nodes.CopyNodes`.
func (self Nodes) CopyNode() Node { return self.CopyNodes() }

func (self Nodes) Procure(fun func(Node) Node) Node {
	if fun == nil {
		return nil
	}
	for _, val := range self {
		node := fun(val)
		if node != nil {
			return node
		}
	}
	return nil
}

func (self Nodes) ProcureLast(fun func(Node) Node) Node {
	if fun == nil {
		return nil
	}
	for i := len(self) - 1; i >= 0; i-- {
		node := fun(self[i])
		if node != nil {
			return node
		}
	}
	return nil
}

// Nodes enclosed in parentheses: ().
type ParenNodes Nodes

// Implement `Node`.
func (self ParenNodes) Append(buf []byte) []byte {
	return appendNodesEnclosed(buf, parenOpen, Nodes(self), parenClose)
}

// Implement `Node`. Also implements `fmt.Stringer` for debug purposes.
func (self ParenNodes) String() string { return appenderStr(&self) }

// Implement `Coll`. Free cast with no allocation.
func (self ParenNodes) Nodes() Nodes { return Nodes(self) }

// Implement `Copier` by calling `Nodes.Copy`.
func (self ParenNodes) CopyNode() Node { return ParenNodes(self.Nodes().CopyNodes()) }

// Implement `Walker` by calling `Nodes.WalkNode`.
func (self ParenNodes) WalkNode(fun func(Node)) { self.Nodes().WalkNode(fun) }

// Implement `PtrWalker` by calling `Nodes.WalkNodePtr`.
func (self ParenNodes) WalkNodePtr(fun func(*Node)) { self.Nodes().WalkNodePtr(fun) }

// Nodes enclosed in brackets: [].
type BracketNodes Nodes

// Implement `Node`.
func (self BracketNodes) Append(buf []byte) []byte {
	return appendNodesEnclosed(buf, bracketOpen, Nodes(self), bracketClose)
}

// Implement `Node`. Also implements `fmt.Stringer` for debug purposes.
func (self BracketNodes) String() string { return appenderStr(&self) }

// Implement `Coll`. Free cast with no allocation.
func (self BracketNodes) Nodes() Nodes { return Nodes(self) }

// Implement `Copier` by calling `Nodes.Copy`.
func (self BracketNodes) CopyNode() Node { return BracketNodes(self.Nodes().CopyNodes()) }

// Implement `Walker` by calling `Nodes.WalkNode`.
func (self BracketNodes) WalkNode(fun func(Node)) { self.Nodes().WalkNode(fun) }

// Implement `PtrWalker` by calling `Nodes.WalkNodePtr`.
func (self BracketNodes) WalkNodePtr(fun func(*Node)) { self.Nodes().WalkNodePtr(fun) }

// Nodes enclosed in braces: {}.
type BraceNodes Nodes

// Implement `Node`.
func (self BraceNodes) Append(buf []byte) []byte {
	return appendNodesEnclosed(buf, braceOpen, Nodes(self), braceClose)
}

// Implement `Node`. Also implements `fmt.Stringer` for debug purposes.
func (self BraceNodes) String() string { return appenderStr(&self) }

// Implement `Coll`. Free cast with no allocation.
func (self BraceNodes) Nodes() Nodes { return Nodes(self) }

// Implement `Copier` by calling `Nodes.Copy`.
func (self BraceNodes) CopyNode() Node { return BraceNodes(self.Nodes().CopyNodes()) }

// Implement `Walker` by calling `Nodes.WalkNode`.
func (self BraceNodes) WalkNode(fun func(Node)) { self.Nodes().WalkNode(fun) }

// Implement `PtrWalker` by calling `Nodes.WalkNodePtr`.
func (self BraceNodes) WalkNodePtr(fun func(*Node)) { self.Nodes().WalkNodePtr(fun) }
